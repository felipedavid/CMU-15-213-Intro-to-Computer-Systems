1.1:
A)
    S = 1/((1-0.6) + 0.6/1.5)
    S = 1.25
    The speed up will be 1.25x

B)
    1.67 = 1/(0.4 + 0.6/3)
    k = 3
    Factor of 3, 300km/hr

1.2:
    4 = 1/(0.1 + 0.9/k)
    k = 6
    This part would need to get 6x faster

2.1:
A) 0x39A7F8 -> 0011 1001 1010 0111 1111 1000
B) 1100 1001 0111 1011 -> 0xC97B
C) 0xD5E4C -> 1101 0101 1110 0100 1100
D) 0010 0110 1110 0111 1011 0101 -> 0x26E7B5

2.2:
     n   2^n(dec)  2^n(hex)
    9      512      0x200
    19   524288    0x80000
    14    16384    0x4000
    16    65536    0x10000
    17   131072    0x20000
     5      32     0x20
    7      128     0x80

2.3:
    0   0000 0000   0x00
  167   1010 0111   0xA7
   62   0011 1110   0x3E
  188   1011 1100   0xBC
   55   0011 0111   0x37
  136   1000 1000   0x88
  243   1111 0011   0xF3
   82   0101 0010   0x52
  252   1010 1100   0xAC
  231   1110 0111   0xE7

2.4:
A. 0x503c + 0x8 = 0x5044
B. 0x503c - 0x40 = 0x4ffc
C. 0x503c + 0x40 = 0x507c
D. 0x50ea - 0x503c = 0xae


2.5:
int val = 0x87654321
A. Litte endian: 21       Big endian: 87
B. Litte endian: 21 43    Big endian: 87 65
C. Litte endian: 21 43 65 Big endian: 87 65 43


2.6:
A. 0x359141 -> 0011 0101 1001 0001 0100 0001
   0x4A564504 -> 0100 1010 0101 0110 0100 0101 0000 0100

B.       001101011001000101000001
   01001010010101100100010100000100
            *********************

2.7:
61 62 63 64 65 66


2.8:
a   [01101001]
b   [01010101]

~a  [10010110]
~b  [10101010]

a & b  [01000001]
a | b  [01111101]
a ^ b  [00111100]


2.9:
A.  Black <-> White
    Blue  <-> Yellow
    Green <-> Magenta
    Cyan  <-> Red

B.  Blue | Green  = Cyan
    Yellow & Cyan = Green
    Red ^ Magenta = Blue


2.10
    Step        *x      *y
    Initially    a       b
    Step 1       a      a^b
    Step 2       b      a^b
    Step 3       b       a

2.11
A. X
B. Because we are trying to swap the same variable. The pointers point to the same
location. When we execute the Step 1, the resul of a ^ a = 0 is stored in *y that
reference the same location as *x, so, both pointers point to a variable with value 0.
C. Just change the loop conditional to: first < last, instead of first <= last


2.12
A. x & 0xFF
B. x ^ ~0xFF
C. x | 0xFF


2.13
int bool_or(int x, int y) {
    int result = bis(x, y);
    return result;
}

int bool_xor(int x, int y) {
    int result = bis(bic(x, y), bic(y, x));
    return result;
}


2.14
x = 0x66, y = 0x39
x & y   = 0x20
x | y   = 0x7F
~x | ~y = 0xDF
x & !y  = 0x0
x && y  = 0x1
x || y  = 0x1
!x || !y = 0x0
x && ~y  = 0x1


2.15
!(x^y)


2.16                                Logical           Arithmetic
    x              x << 3            x >> 2            x >> 2
Hex   Binary    Binary   Hex     Binary    Hex      Binary  Hex
0xC3 11000011  00011000 0x18    00110000 0x30      11110000 0xF0
0x75 01110101  10101000 0xA8    00011101 0x1D      00011101 0x1D
0x87 10000111  00111000 0x38    00010000 0x10      11100001 0xE1
0x66 01100110  00110000 0x30    00011001 0x19      00011001 0x19


2.17
Hex    Binary    B2U     B2T
0xE     1110      14      -2
0x0     0000      0       0
0x5     0101      5       5
0x8     1000      8       -8
0xD     1101      13      -3
0xF     1111      15      -1


2.18
A. 736
B. -88
C. 40
D. -48
E. 120
F. 136
G. 504
H. 192


2.19
-8    8
-3    13
-2    14
-1    15
 0    0
 5    5


2.20
For the first 4 entries we've used T2U(x)=x+2^4 and in the last two entries
we've used: T2U(x)=x


2.21
unsigned   1
signed     1
unsigned   0
signed     1
unsigned   1

2.22
A. 1100   = -4
B. 11100  = -4
C. 111100 = -4


2.23
A.
    w          fun1(w)      fun2(w)
0x00000076   0x00000076   0x00000076
0x87654321   0x00000021   0x00000021
0x000000C9   0x000000C9   0xFFFFFFC9
0xEDCBA987   0x00000087   0xFFFFFF87

B. fun1: Extract the value of the less significant byte of a 32 bit word.
    Resulting in a number between 0 and 255.
   fun2: Extract the value of the less significant byte of a 32 bit word
   conserving the sign. Resulting in a number between -128 and 127.


2.24
uns   two's comp
 0        0
 2        2
 1        1
 3        3
 7       -1


2.25
This error happens because the result of exepression legnth-1 when length
is zero, results in UMax (underflow), and when we compare i <= length-1
i is seen as a unsigned value and the loop will run til i > UMax what is
impossible. So the program will keep running throught memory until it finds
something that are not allowed and crashes.
The code can be fixed by declaring length to be integer and the comparision
less than "<".


2.26
This function appear to work fine when strlen(s) >= strlen(t), but returns the
wrong value in the other cases. This happens because the strlen function
returns a size_t type value that is unsigned. So, when the subtraction occur
and we get a negative value, that value is unsigned so will be actually
postive and always greater than 0. Returning always true.
The code can be fixed by just changing the expression to "strlen(s) >
strlen(t)".


2.27
int uadd_ok(unsigned x, unsigned y) {
    return (x + y) >= x;
}


2.28
    x         -x  
Hex  Dec   Dec  Hex
 0    0     0    0
 5    5    11    B
 8    8     8    8
 D   13     3    3
 F   15     1    1


 2.29
   x    y     x+y     x+y t      case
 -12   -15    -27       5         1
10100 10001  100101   00101
 -8     -8    -16      -16        2
11000 11000   10000   10000
 -9      8     -1      -1         2
10111 01000   11111   11111
  2     5       7       7         3
00010 00101   00111   00111
 12     4      16      -16        4
01100 00100  010000   10000


2.30
int tadd_ok(int x, int y) {
    int pos_over = x < 0 && y < 0 && (x + y) >= 0;
    int neg_over = x >= 0 && y >= 0 && (x + y) < 0;
    return !pos_over && !neg_over;
}


2.31
Because it dosen't really check overflow. "sum-x == y" will always be true
even when the value overflows.


2.32
TMin. Just check for TMin.


2.33
Hex Dec   Dec Hex
 0   0     0   0
 5   5    -5   B
 8  -8    -8   8
 D  -3     3   3
 F  -1     1   1
 The bit patterns are the same


2.34
Un  4 [100]  5 [101]  20 [10100]  4 [100]
Tw -4 [100] -3 [101]  12 [1100] -4 [100]

Un  2 [010]  7 [111]  14 [1110]  6 [110]
Tw  2 [010] -1 [111]  -2 [110]  -2 [110]

Un  6 [110]  6 [110]  36 [100100]  4 [100]
Tw -2 [110] -2 [110]   4 [100]    -4 [100]


3.1
%rax            0x100 // register
0x104           0xAB  // absolute address
$0x108          0x108 // immediate
(%rax)          0xFF  // address 0x100
4(%rax)         0xAB  // address 0x104
9(%rax,%rdx)    0x11  // address 0x10c
260(%rcx,%rdx)  0x13  // address 0x108
0xFC(,%rcx,4)   0xFF  // address 0x100
(%rax, %rdx, 4) 0x11  // address 0x10c


3.2
movl %eax, (%rsp)
movw (%rax), %dx
movb $0xFF, %bl
movb (%rsp,%rdx,4), %dl
movq (%rdx), %rax
movw %dx, (%rax)


3.3
movb $0xF, (%ebx) // We are referencing memory with only to a 32 bit register
movl %rax, (%rsp) // We are trying to move a double word from a quad word register
movw (%rax), 4(%4rsp) // we can't move something from memory to memory
movb %al, %sl // sl don't refer to any real register
movq %rax, $0x123 // We can't move something into a immediate
movl %eax, %dx // Destination operator has the wrong size 
movb %si, 8(%rbp) // we specify that we are moving 8 bits in the instructions, but %si is 16 bits
