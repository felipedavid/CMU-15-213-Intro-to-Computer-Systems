3.1:
%rax             0x100
0x104            0xAB
$0x108           0x108
(%rax)           0xFF
4(%rax)          0xAB
9(%rax,%rdx)     0x11
260(%rcx,%rdx)   0x13
0xFC(,%rcx,4)    0xFF
(%rax,%rdx,4)    0x11

3.2:
movl %eax, (%rsp)
movw (%rax), %dx
movb $0xFF, %bl
movb (%rsp,%rdx,4), %dl
movq (%rdx), %rax
movw %dx, (%rax)

3.3:
movb $0xF, (%ebx) // We can't use the low 32 bits of a register to compute the address of a memory reference
movl %rax, (%rsp) // The instruction suffix is imcotible with operand size
movw (%rax), 4(%rsp) // The move instruction can't have two operands referencing memory
movb %al, %sl // %sl is not a real register
movq %rax, $0x123 // We copy a value to a immediate, it dosen't make sense
movl %eax, %rdx // Instruction suffix and operand size mismatch
movb %si, 8(%rbp) // Mismatch on instruction suffix and  operand size

3.4:
src_t           dest_t
long            long            movq (%rdi), %rax
                                movq %rax, (%rsi)

char            int             movsbl (%rdi), %eax
                                movl %eax, (%rsi)

char            unsigned        movsbl (%rdi), %eax
                                movl %eax, (%rsi)

unsigned char   long            movzbq (%rdi), %rax
                                movq %rax, (%rsi)

int             char            movl (%rdi), %eax
                                movb %al, (%rsi)

unsigned        unsigned char   movl (%rdi), %eax
                                movb %al, (%rsi)

char            short           movsbw (%rdi), %ax
                                movw %ax, (%rsi)


3.5:
void decode1(long *xp, long *yp, long *zp) {
    long x = *xp;
    long y = *yp;
    long z = *zp;

    *yp = x;
    *zp = y;
    *xp = z;
}


3.6:
leaq 6(%rax), %rdx          x+6
leaq (%rax, %rcx), %rdx     x+y
leaq (%rax,%rcx,4), %rdx    x+4*y
leaq 7(%rax,%rax,8), %rdx   7+9*x
leaq 0xA(,%rcx,4), %rdx     4*y+10
leaq 9(%rax,%rcx,2), %rdx   x+2*y+9


3.7:
short scale3(shrot x, short y, short z) {
    short t = x * 5 + y * 2 + z * 8;
    return t;
}


3.8:
addq %rcx, (%rax)         0x100  0x100
subq %rdx, 8(%rax)        0x108  0xA8
imulq $16, (%rax,%rdx,8)  0x118  0x110
incq 16(%rax)             0x110  0x14
decq %rcx                 %rcx   0x0
subq %rdx, %rax           %rax   0xFD


3.9:
movq %rdi, %rax
salq $4, %rax
movl %esi, %ecx
sarq %cl, %rax


3.10:
long t1 = x | y;
long t2 = t1 >> 3;
long t3 = ~t2;
long t4 = z - t3;


3.11:
A) The effect will be set the register passed in both operands to zero. By the xor property,
if we compute the same value we get 0. This instruction is encoded is less bytes than a
mov instruction.
B) movq $0, %rdx
C) The xor instruction requires 3 byte while the mov instruction require 7.


3.12:
movq %rdx, %r8
movq %rdi, %rax
xor %edx, %edx
divq %rsi
movq %rax, (%r8)
movq %rdx, (%rcx)
ret


3.13:
A. int, <
B. short, >=
C. unsigned char, <=
D. "long long" and "unsigned long long", !=


3.14:
A. long, >=
B. short or unsigned short, ==
C. unsigned char, >
D. int, <=


3.15:
A. 4003fe
B. 400425
C. 500543 400545
D. 400560


3.16:
A)
if (p == 0)   goto done;
if (*p  >= a) goto done;
*p = a;
done:
    return

B) Because we can't do compound logic statements in assembly. So we have to do each
logic comparison with multiple conditional branches.


3.17:
A. 
int result;
if (x < y) goto ge_cnt;
goto lt_cnt;
lt_cnt:
    lt_cnt++;
    result = y - x;
    return result;
ge_cnt:
    ge_cnt++;
    result = x - y;
    return result;


3.18:
    long val = x * y + z;
    if (x < -3) {
        if (y < z)
            val = x * y;
        else
            val = y * z;
    } else if (x > 2) {
        val = x * z;
    }
    return val;


3.19:
A. 30 cycles
B. 46 cycles


3.20:
leaq 7(%rdi), %rax // res = x + 7
testq %rdi, %rdi   
cmovns %rdi, %rax // if x >= 0, res = x
sarq $3, %rax     // res /= 8
ret
A. return >= 0 ? x : x + 7 / ;

3.21:
long test(long x, long y) {
    long val = x * 8;
    if (y > 0) {
        if (x < y) val = y - x;
        else val = x & y;
    } else if (y <= -2) val = x + y;
    return val;
}


3.22:
A. 13
B. It dosen't overflow.


3.23:
A. x = rax, y = rcx, n = rbx
B. The compiler notices that all operations are done in X, and X is always on register,
so it changes the code to always reference the register instead of memory.
C.
long dw_loop(long x)
dw_loop:
    movq %rdi, %rax // set result = x;
    movq %rdi, %rcx // y = x * x;
    imulq %rdi, %rcx 
    leaq (%rdi, %rdi), %rdx // n = x * 2;
.L2:
    leaq 1(%rcx,%rax), %rax // result += y+1;
    sub $1, %rdx // n--;
    testq %rdx, %rdx
    jg .L2 // If n > 0, goto .L2
    ret


3.24:
long loop_while(long a, long b) {
    long result = 1;
    while (a < b) {
        result = result * (a + b);
        a = a + 1;
    }
    return result;
}


3.25:
long loop_while2(long a, long b) {
    lnog result = b;
    while (b > 0) {
        result = result * a;
        b = b - a;
    }
    return result;
}


3.26:
A. Jump to middle
B. 
short val = 0;
while (x) {
    val ^= x;
    x = x >> 1;
}
return val & 1;
C. I have no idea.


3.27:
long fact_for(long n) {
    int result = 1;
    int i = 2;
    if (n <= 1) goto end;
loop:
    result *= i;
    i++;
    if (i <= n) goto loop;
end:
    return result;
}


3.28:
A.
long fun_b(unsigned long x) {
    long val = 0;
    long i;
    for (i = 100; i != 0; i--) {
        val = x & 1 | (val + val);
        x >>= 1;
    }
    return val;
}


3.29:
A. It would be a infinite loop, the continue statements don't let i to udpate it's value.
B. Make the goto jump all loop body with exception of the update portion.
