1.1:
A)
    S = 1/((1-0.6) + 0.6/1.5)
    S = 1.25
    The speed up will be 1.25x

B)
    1.67 = 1/(0.4 + 0.6/3)
    k = 3
    Factor of 3, 300km/hr

1.2:
    4 = 1/(0.1 + 0.9/k)
    k = 6
    This part would need to get 6x faster

2.1:
A) 0x39A7F8 -> 0011 1001 1010 0111 1111 1000
B) 1100 1001 0111 1011 -> 0xC97B
C) 0xD5E4C -> 1101 0101 1110 0100 1100
D) 0010 0110 1110 0111 1011 0101 -> 0x26E7B5

2.2:
     n   2^n(dec)  2^n(hex)
    9      512      0x200
    19   524288    0x80000
    14    16384    0x4000
    16    65536    0x10000
    17   131072    0x20000
     5      32     0x20
    7      128     0x80

2.3:
    0   0000 0000   0x00
  167   1010 0111   0xA7
   62   0011 1110   0x3E
  188   1011 1100   0xBC
   55   0011 0111   0x37
  136   1000 1000   0x88
  243   1111 0011   0xF3
   82   0101 0010   0x52
  252   1010 1100   0xAC
  231   1110 0111   0xE7

2.4:
A. 0x503c + 0x8 = 0x5044
B. 0x503c - 0x40 = 0x4ffc
C. 0x503c + 0x40 = 0x507c
D. 0x50ea - 0x503c = 0xae


2.5:
int val = 0x87654321
A. Litte endian: 21       Big endian: 87
B. Litte endian: 21 43    Big endian: 87 65
C. Litte endian: 21 43 65 Big endian: 87 65 43


2.6:
A. 0x359141 -> 0011 0101 1001 0001 0100 0001
   0x4A564504 -> 0100 1010 0101 0110 0100 0101 0000 0100

B.       001101011001000101000001
   01001010010101100100010100000100
            *********************

2.7:
61 62 63 64 65 66


2.8:
a   [01101001]
b   [01010101]

~a  [10010110]
~b  [10101010]

a & b  [01000001]
a | b  [01111101]
a ^ b  [00111100]


2.9:
A.  Black <-> White
    Blue  <-> Yellow
    Green <-> Magenta
    Cyan  <-> Red

B.  Blue | Green  = Cyan
    Yellow & Cyan = Green
    Red ^ Magenta = Blue


2.10
    Step        *x      *y
    Initially    a       b
    Step 1       a      a^b
    Step 2       b      a^b
    Step 3       b       a

2.11
A. X
B. Because we are trying to swap the same variable. The pointers point to the same
location. When we execute the Step 1, the resul of a ^ a = 0 is stored in *y that
reference the same location as *x, so, both pointers point to a variable with value 0.
C. Just change the loop conditional to: first < last, instead of first <= last


2.12
A. x & 0xFF
B. x ^ ~0xFF
C. x | 0xFF

2.13
int bool_or(int x, int y) {
    int result = bis(x, y);
    return result;
}

int bool_xor(int x, int y) {
    int result = ;
    return result;
}
